<!DOCTYPE html>
<html>
    <head>
        <title>INT Tools</title>
        <meta charset="utf-8" />
        <!--

            Copyright (c) 2025 speedydelete

            Permission is hereby granted, free of charge, to any person obtaining a copy
            of this software and associated documentation files (the "Software"), to deal
            in the Software without restriction, including without limitation the rights
            to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
            copies of the Software, and to permit persons to whom the Software is
            furnished to do so, subject to the following conditions:

            The above copyright notice and this permission notice shall be included in all
            copies or substantial portions of the Software.

            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
            IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
            FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
            AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
            LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
            OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
            SOFTWARE.

        -->
        <style>

* {
    box-sizing: border-box;
}

html, body {
    position: absolute;
    inset: 0;
    height: 100%;
    width: 100%;
}

body {
    margin: 0;
    padding: 30px 40px;
    display: flex;
    flex-flow: row wrap;
    gap: 40px;
}

h2 {
    margin: 0;
    padding: 20px 0;
    font-weight: bold;
    font-size: 1.5rem;
    text-align: center;
}

#transitions {
    border-collapse: collapse;
    user-select: none;
}

#transitions > tr, #transitions > tr > td {
    border: 1px solid #a2a9b1;
}

#transitions th {
    background-color: #eaecf0;
    border: 1px solid #a2a9b1;
    padding-top: 3px;
    padding-bottom: 3px;
}

#transitions > tr:not(:first-child) > th {
    padding-left: 10px;
    padding-right: 10px;
}

#transitions > tr > td {
    padding: 5px;
}

.transition {
    border-collapse: collapse;
}

.transition-cell {
    height: 15px;
    width: 15px;
    min-height: 15px;
    min-width: 15px;
    max-height: 15px;
    max-width: 15px;
    border: 2px solid #bfbfbf;
}

.transition-cell-1 {
    background-color: #007fff;
}

.transition-cell-2 {
    background-color: #000000;
}

textarea {
    font-family: monospace;
    font-size: 13px;
    resize: none;
}

textarea:focus {
    outline: none;
}

button {
    font-family: inherit;
    font-size: inherit;
    background-color: inherit;
    color: inherit;
    border: 1px solid black;
    padding: 3px 6px;
}

#middle {
    display: flex;
    flex-direction: column;
    height: calc(100% - 60px);
}

#rle-adder {
    display: flex;
    flex-direction: column;
    gap: 20px;
    align-items: start;
}

#rle-adder-buttons {
    width: 100%;
    display: flex;
    flex-direction: row;
}

#clear {
    margin-left: auto;
}

#patterns {
    flex-grow: 1;
    min-height: 0;
    margin-top: 30px;
    padding-right: 30px;
    overflow-y: auto;
    max-height: calc(100% - 234px - 2.5rem);
    display: flex;
    flex-direction: column;
    gap: 20px;
}

#patterns > * {
    position: relative;
    padding: 5px;
    display: flex;
    flex-direction: column;
    gap: 5px;
    border: 1px solid black;
    background-color: #bfbfbf;
}

#patterns .type {
    font-size: 1.25rem;
    font-weight: bold;
}

#patterns .info {
    white-space: pre-wrap;
    color: #3f3f3f;
}

#patterns input[type=checkbox] {
    position: absolute;
    top: 5px;
    right: 5px;
}

#patterns .link {
    position: absolute;
    bottom: 5px;
    right: 5px;
    color: #3366cc;
    user-select: none;
}

#rc {
    width: 400px;
}

#combine {
    margin: 20px 0;
}

#combine-out {
    white-space: pre-wrap;
}

        </style>
    </head>
    <body>
        <div>
            <h2>Transitions</h2>
            <table id="transitions">
                <tr>
                    <th></th>
                    <th>0</th>
                    <th>1</th>
                    <th>2</th>
                    <th>3</th>
                    <th>4</th>
                    <th>5</th>
                    <th>6</th>
                    <th>7</th>
                    <th>8</th>
                </tr>
            </table>
        </div>
        <div id="middle">
            <h2>Patterns</h2>
            <div id="rle-adder">
                <textarea id="rle" placeholder="Enter RLE..." rows="10" cols="70"></textarea>
                <div id="rle-adder-buttons">
                    <button id="add">Add</button>
                    <button id="clear">Clear</button>
                </div>
            </div>
            <div id="patterns"></div>
        </div>
        <div id="rc">
            <h2>Rule combiner</h2>
            <div>Select added patterns using the checkboxes and then press "Combine" to get the combined min/maxrule!</div>
            <button id="combine">Combine</button>
            <div id="combine-out"></div>
        </div>
        <script>

'use strict';

const TRANSITIONS = {
    0: {
        c: [0, 0, 0, 0, 2, 0, 0, 0, 0],
    },
    1: {
        c: [1, 0, 0, 0, 2, 0, 0, 0, 0],
        e: [0, 1, 0, 0, 2, 0, 0, 0, 0],
    },
    2: {
        c: [1, 0, 1, 0, 2, 0, 0, 0, 0],
        e: [0, 1, 0, 1, 2, 0, 0, 0, 0],
        k: [0, 1, 0, 0, 2, 0, 0, 0, 1],
        a: [1, 1, 0, 0, 2, 0, 0, 0, 0],
        i: [0, 1, 0, 0, 2, 0, 0, 1, 0],
        n: [1, 0, 0, 0, 2, 0, 0, 0, 1],
    },
    3: {
        c: [1, 0, 1, 0, 2, 0, 0, 0, 1],
        e: [0, 1, 0, 1, 2, 1, 0, 0, 0],
        k: [0, 1, 0, 1, 2, 0, 0, 0, 1],
        a: [1, 1, 0, 1, 2, 0, 0, 0, 0],
        i: [1, 0, 0, 1, 2, 0, 1, 0, 0],
        n: [1, 0, 1, 1, 2, 0, 0, 0, 0],
        y: [1, 0, 1, 0, 2, 0, 0, 1, 0],
        q: [1, 0, 0, 1, 2, 0, 0, 0, 1],
        j: [0, 0, 1, 0, 2, 1, 0, 1, 0],
        r: [0, 1, 1, 0, 2, 0, 0, 1, 0],
    },
    4: {
        c: [1, 0, 1, 0, 2, 0, 1, 0, 1],
        e: [0, 1, 0, 1, 2, 1, 0, 1, 0],
        k: [0, 1, 1, 1, 2, 0, 0, 0, 1],
        a: [1, 0, 0, 1, 2, 0, 1, 1, 0],
        i: [1, 0, 1, 1, 2, 1, 0, 0, 0],
        n: [1, 0, 0, 1, 2, 0, 1, 0, 1],
        y: [1, 0, 1, 0, 2, 0, 1, 1, 0],
        q: [1, 1, 0, 1, 2, 0, 0, 0, 1],
        j: [0, 0, 1, 1, 2, 0, 0, 1, 0],
        r: [0, 1, 1, 0, 2, 1, 0, 1, 0],
        t: [1, 1, 1, 0, 2, 0, 0, 1, 0],
        w: [1, 0, 0, 1, 2, 0, 0, 1, 1],
        z: [1, 1, 0, 0, 2, 0, 0, 1, 1],
    },
    5: {
        c: [0, 1, 0, 1, 2, 1, 1, 1, 0],
        e: [1, 0, 1, 0, 2, 0, 1, 1, 1],
        k: [1, 0, 1, 0, 2, 1, 1, 1, 0],
        a: [0, 0, 1, 0, 2, 1, 1, 1, 1],
        i: [0, 1, 1, 0, 2, 1, 0, 1, 1],
        n: [0, 1, 0, 0, 2, 1, 1, 1, 1],
        y: [0, 1, 0, 1, 2, 1, 1, 0, 1],
        q: [0, 1, 1, 0, 2, 1, 1, 1, 0],
        j: [1, 1, 0, 1, 2, 0, 1, 0, 1],
        r: [1, 0, 0, 1, 2, 1, 1, 0, 1],
    },
    6: {
        c: [0, 1, 0, 1, 2, 1, 1, 1, 1],
        e: [1, 0, 1, 0, 2, 1, 1, 1, 1],
        k: [1, 0, 1, 1, 2, 1, 1, 1, 0],
        a: [0, 0, 1, 1, 2, 1, 1, 1, 1],
        i: [1, 0, 1, 1, 2, 1, 1, 0, 1],
        n: [0, 1, 1, 1, 2, 1, 1, 1, 0],
    },
    7: {
        c: [0, 1, 1, 1, 2, 1, 1, 1, 1],
        e: [1, 0, 1, 1, 2, 1, 1, 1, 1],
    },
    8: {
        c: [1, 1, 1, 1, 2, 1, 1, 1, 1],
    }
}

function gridToNumber(a, b, c, d, e, f, g, h, i) {
    return (a << 8) | (b << 7) | (c << 6) | (d << 5) | (e << 4) | (f << 3) | (g << 2) | (h << 1) | i;
}

let fullTransitions = {};
for (let [number, letters] of Object.entries(TRANSITIONS)) {
    let outLetters = {};
    for (let [letter, t] of Object.entries(letters)) {
        t = Array.from(t);
        t[4] = 0;
        let allTransitions = new Set();
        for (let j = 0; j < 10; j++) {
            t = [t[6], t[3], t[0], t[7], t[4], t[1], t[8], t[5], t[2]];
            allTransitions.add(gridToNumber(...t));
            allTransitions.add(gridToNumber(t[2], t[1], t[0], t[5], t[4], t[3], t[8], t[7], t[6]));
            allTransitions.add(gridToNumber(t[6], t[7], t[8], t[3], t[4], t[5], t[0], t[1], t[2]));
        }
        outLetters[letter] = Array.from(allTransitions);
    }
    fullTransitions[parseInt(number)] = outLetters;
}

window.addEventListener('load', () => {
    let table = document.getElementById('transitions');
    for (let transition of Object.keys(TRANSITIONS[4])) {
        let row = document.createElement('tr');
        let header = document.createElement('th');
        header.textContent = transition;
        row.appendChild(header);
        for (let i = 0; i <= 8; i++) {
            let elt = document.createElement('td');
            let spec = TRANSITIONS[i][transition];
            if (spec) {
                let table = document.createElement('table');
                table.className = 'transition';
                for (let y = 0; y < 3; y++) {
                    let row = document.createElement('tr');
                    for (let x = 0; x < 3; x++) {
                        let elt = document.createElement('td');
                        elt.className = 'transition-cell transition-cell-' + spec[y * 3 + x];
                        row.appendChild(elt);
                    }
                    table.appendChild(row);
                }
                elt.appendChild(table);
            }
            row.appendChild(elt);
        }
        table.appendChild(row);
    }
});



function error(msg) {
    alert(msg);
    throw new Error(msg);
}


function parseTransition(num, minus, trs, type) {
    let out = [];
    if (trs.length === 0) {
        for (let char in TRANSITIONS[num]) {
            out.push(type + num + char);
        }
    } else if (minus) {
        let outTrs = Object.keys(TRANSITIONS[num]).join('');
        for (let char of trs) {
            if (!outTrs.includes(char)) {
                error(`Invalid transition ${num}${char}!`);
            }
            outTrs = outTrs.replace(char, '');
        }
        for (let char of outTrs) {
            out.push(type + num + char);
        }
    } else {
        for (let char of trs) {
            if (!(char in TRANSITIONS[num])) {
                error(`Invalid transition: ${num}${char}!`);
            }
            out.push(type + num + char);
        }
    }
    return out;
}

function _parseTransitions(part, type) {
    let out = [];
    let num = parseInt(part[0]);
    let minus = false;
    let trs = '';
    for (let char of part.slice(1)) {
        if ('012345678'.includes(char)) {
            out.push(...parseTransition(num, minus, trs, type));
            num = parseInt(char);
            minus = false;
            trs = '';
        } else if (char === '-') {
            minus = true;
        } else {
            trs += char;
        }
    }
    out.push(...parseTransition(num, minus, trs, type));
    return out;
}

function parseTransitions(rule) {
    let match = rule.match(/^B([0-9a-z\-]*)\/S([0-9a-z\-]*)$/);
    if (!match) {
        error('Invalid rule!');
    }
    return [].concat(_parseTransitions(match[1], 'B'), _parseTransitions(match[2], 'S'));
}

const ALL_TRANSITIONS = parseTransitions('B012345678/S012345678');

function transitionsToParsedRule(trs) {
    let out = new Uint8Array(512);
    for (let [type, num, char] of trs) {
        for (let tr of fullTransitions[num][char]) {
            if (type === 'B') {
                out[tr] = 1;
            } else {
                out[tr | (1 << 4)] = 1;
            }
        }
    }
    return out;
}

function _transitionsToRule(trs) {
    let out = '';
    for (let number = 0; number <= 8; number++) {
        let letters = [];
        let allLetters = Object.keys(TRANSITIONS[number]);
        for (let letter of allLetters) {
            if (trs.includes(number + letter)) {
                letters.push(letter);
            }
        }
        if (letters.length === 0) {
            continue;
        }
        letters.sort();
        out += number;
        let normal = letters.join('');
        if (letters.length !== allLetters.length) {
            let minus = '-' + allLetters.filter(x => !letters.includes(x)).sort().join('');
            if (minus.length < normal.length) {
                out += minus;
            } else {
                out += normal;
            }
        }
    }
    return out;
}

function transitionsToRule(trs) {
    let b = trs.filter(x => x[0] === 'B').map(x => x[1] + x[2]);
    let s = trs.filter(x => x[0] === 'S').map(x => x[1] + x[2]);
    return 'B' + _transitionsToRule(b) + '/S' + _transitionsToRule(s);
}

function parseRule(rule) {
    return transitionsToParsedRule(parseTransitions(rule));
}


class Pattern {

    data;
    height;
    width;
    rule;
    parsedRule = null;
    x = 0;
    y = 0;

    constructor(height, width, rule, data) {
        if (height instanceof Pattern) {
            this.data = height.data;
            this.height = height.height;
            this.width = height.width;
            this.rule = height.rule;
            this.parsedRule = height.parsedRule;
        } else {
            this.data = data ?? new Uint8Array(height * width);
            this.height = height;
            this.width = width;
            this.rule = rule;   
        }
    }

    get population() {
        return this.data.reduce((x, y) => x + y, 0);
    }

    static fromRLE(rle) {
        let data = [[]];
        let [firstLine, ...lines] = rle.split('\n');
        let rule = 'B3/S23';
        let match = firstLine.match(/^\s*x\s*=\s*(\d+)\s*,?\s*y\s*=\s*(\d+)\s*,?\s*(?:rule\s*=\s*(\S+)\s*)?$/);
        if (match) {
            if (typeof match[3] === 'string') {
                rule = match[3];
            }
        } else {
            error('Invalid RLE!');
        }
        let chars = lines.join('');
        let row = [0];
        let num = '';
        for (let char of chars) {
            if (char === '!') {
                break;
            } else if ('0123456789'.includes(char)) {
                num += char;
            } else if (char === 'b' || char === 'o') {
                let elt = char === 'b' ? 0 : 1;
                if (num === '') {
                    row.push(elt);
                } else {
                    let count = parseInt(num);
                    for (let i = 0; i < count; i++) {
                        row.push(elt);
                    }
                    num = '';
                }
            } else if (char === '$') {
                row.push(0);
                data.push(row);
                row = [0];
                if (num !== '') {
                    let count = parseInt(num);
                    for (let i = 1; i < count; i++) {
                        data.push([]);
                    }
                    num = '';
                }
            }
        }
        row.push(0);
        data.push(row, []);
        let width = Math.max(...data.map(x => x.length));
        data.forEach(x => {
            while (x.length < width) {
                x.push(0);
            }
        });
        return new Pattern(data.length, width, rule, new Uint8Array([].concat(...data)));
    }

    toRLE() {
        let data = [];
        for (let y = 0; y < this.height; y++) {
            let row = [];
            for (let x = 0; x < this.width; x++) {
                row.push(this.data[y * this.width + x]);
            }
            data.push(row);
        }
        let xOffset = this.x;
        let yOffset = this.y;
        while (data[0].every(x => x === 0) && data.length > 0) {
            data.shift();
            xOffset++;
        }
        while (data.at(-1)?.every(x => x === 0) && data.length > 0) {
            data.pop();
        }
        while (data.every(x => x[0] === 0) && data[0]?.length > 0) {
            data.forEach(x => x.shift());
            yOffset++;
        }
        while (data.every(x => x.at(-1) === 0) && data[0]?.length > 0) {
            data.forEach(x => x.pop());
        }
        let beforeRLE = '';
        for (let row of data) {
            if (row !== undefined) {
                for (let item of row) {
                    if (item === 0) {
                        beforeRLE += 'b';
                    } else if (item === 1) {
                        beforeRLE += 'o';
                    } else {
                        beforeRLE += RLE_CHARS[item];
                    }
                }   
            }
            beforeRLE += '$';
        }
        beforeRLE = beforeRLE.split('$').map(x => x.replace(/b+$/, '')).join('$').replaceAll(/^\$+|\$+$/g, '');
        let out = `x = ${data[0] ? data[0].length : 0}, y = ${data.length}, rule = ${this.rule}\n`;
        if (beforeRLE.length === 0) {
            return out + '!';
        }
        let runLength = 1;
        let runChar = beforeRLE[0];
        for (let char of beforeRLE.slice(1)) {
            if (runChar === char) {
                runLength++;
            } else {
                if (runLength === 1) {
                    out += runChar;
                } else {
                    out += runLength + runChar;
                }
                runChar = char;
                runLength = 1;
            }
            if (out.lastIndexOf('\n') < out.length - 60) {
                out += '\n';
            }
        }
        if (runLength === 1) {
            out += runChar;
        } else {
            out += runLength + runChar;
        }
        return out + '!\n';
    }

    runGeneration() {
        if (!this.parsedRule) {
            this.parsedRule = parseRule(this.rule);
        }
        let out = new Uint8Array(this.height * this.width);
        let edgeStates = 0;
        let i = 0;
        let lowX = this.width;
        let highX = -1;
        let lowY = this.height;
        let highY = -1;
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                let value = this.parsedRule[
                    ((this.data[i - this.width - 1] || 0) << 8) |
                    ((this.data[i - this.width    ] || 0) << 7) |
                    ((this.data[i - this.width + 1] || 0) << 6) |
                    ((this.data[i - 1             ] || 0) << 5) |
                    ((this.data[i                 ] || 0) << 4) |
                    ((this.data[i + 1             ] || 0) << 3) |
                    ((this.data[i + this.width - 1] || 0) << 2) |
                    ((this.data[i + this.width    ] || 0) << 1) |
                    (this.data[i + this.width + 1] || 0)
                ];
                out[i] = value;
                if (value) {
                    if (y < lowY) {
                        lowY = y;
                    }
                    if (y > highY) {
                        highY = y;
                    }
                    if (x < lowX) {
                        lowX = x;
                    }
                    if (x > highX) {
                        highX = x;
                    }
                }
                i++;
            }
        }
        if (highX < lowX || highY < lowY) {
            this.data = new Uint8Array(0);
            this.width = 0;
            this.height = 0;
            return;
        }
        let growTop = lowY === 0;
        let growBottom = highY === this.height - 1;
        let growLeft = lowX === 0;
        let growRight = highX === this.width - 1;
        let shrinkTop = lowY - 1;
        if (shrinkTop < 0) {
            shrinkTop = 0;
        }
        let shrinkBottom = this.height - 2 - highY;
        if (shrinkBottom < 0) {
            shrinkBottom = 0;
        }
        let shrinkLeft = lowX - 1;
        if (shrinkLeft < 0) {
            shrinkLeft = 0;
        }
        let shrinkRight = this.width - 2 - highX;
        if (shrinkRight < 0) {
            shrinkRight = 0;
        }
        let newHeight = this.height + (growTop ? 1 : 0) + (growBottom ? 1 : 0) - shrinkTop - shrinkBottom;
        let newWidth  = this.width  + (growLeft ? 1 : 0) + (growRight ? 1 : 0) - shrinkLeft - shrinkRight;
        if (newHeight < 0) {
            newHeight = 0;
        }
        if (newWidth < 0) {
            newWidth = 0;
        }
        let newData = new Uint8Array(newWidth * newHeight);
        let yOffset = (growTop ? 1 : 0) - shrinkTop;
        let xOffset = (growLeft ? 1 : 0) - shrinkLeft;
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                let value = out[y * this.width + x];
                if (value) {
                    let ny = y + yOffset;
                    let nx = x + xOffset;
                    if (ny >= 0 && ny < newHeight && nx >= 0 && nx < newWidth) {
                        newData[ny * newWidth + nx] = value;
                    }
                }
            }
        }
        this.height = newHeight;
        this.width = newWidth;
        this.data = newData;
        this.y += shrinkTop;
        this.y -= growTop ? 1 : 0;
        this.x += shrinkLeft;
        this.x -= growLeft ? 1 : 0;
    }

}


function findType(pattern, gens) {
    let p = new Pattern(pattern);
    let pops = [p.population];
    for (let i = 0; i < gens; i++) {
        p.runGeneration();
        pops.push(p.population);
        if (p.data.every((x, i) => x === pattern.data[i])) {
            let x = p.x - pattern.x;
            let y = p.y - pattern.y;
            return {p: i + 1, x, y};
        }
        for (let p = 1; p < i/4; p++) {
            let fpops = pops.filter((x, i) => i % p === 0);
            let diffs = fpops.slice(0, -1).map((x, i) => fpops[i + 1] - x);
            if (diffs.every(x => x === diffs[0])) {
                return {linear: true, p, d: diffs[0]};
            }
        }
    }
    return {error: true};
}

function verifyType(pattern, type) {
    if (type.error) {
        return true;
    }
    if (type.linear) {
        let p = new Pattern(pattern);
        let pops = [];
        for (let i = 0; i <= type.p * 8; i++) {
            if (i % type.p === 0) {
                pops.push(p.population);
            }
            p.runGeneration();
        }
        return pops.every((x, i) => i === 0 || x - pops[i - 1] === type.d);
    } else {
        let p = new Pattern(pattern);
        for (let i = 0; i < type.p; i++) {
            p.runGeneration();
        }
        return p.data.every((x, i) => x === pattern.data[i]) && p.x === type.x && p.y === type.y;
    }
}

function typeToString(pattern, type) {
    if (type.error) {
        return '<cannot identify>';
    } else if (type.linear) {
        return `p${type.p} linear growth pattern`;
    } else if (type.x === 0 && type.y === 0) {
        if (type.p === 1) {
            return `${pattern.population}-cell still life`;
        }
        return `p${type.p} oscillator`;
    } else {
        return `(${type.x}, ${type.y})c/${type.p} spaceship`;
    }
}

function identify(pattern, gens) {
    let p = new Pattern(pattern);
    let type = findType(p, gens);
    let trs = parseTransitions(p.rule);
    let min = trs.slice();
    let max = trs.slice();
    for (let tr of ALL_TRANSITIONS) {
        let newTrs;
        let index = trs.indexOf(tr);
        if (index !== -1) {
            newTrs = trs.toSpliced(index, 1);
        } else {
            newTrs = trs.concat(tr);
        }
        p.parsedRule = transitionsToParsedRule(newTrs);
        if (verifyType(p, type)) {
            if (index !== -1) {
                min = min.toSpliced(min.indexOf(tr), 1);
            } else {
                max.push(tr);
            }
        }
    }
    p.parsedRule = parseRule(p.rule);
    return {
        type,
        min,
        max,
        typeStr: typeToString(pattern, type),
        minStr: transitionsToRule(min),
        maxStr: transitionsToRule(max),
        rle: pattern.toRLE(),
    };
}

let patterns = [];

let checkedPatterns = new Set();

let rleTextarea = document.getElementById('rle');
let patternsDiv = document.getElementById('patterns');

function addPattern(pattern, save = true) {
    patterns.push(pattern);
    if (save) {
        localStorage.intToolsPatterns = JSON.stringify(patterns);
    }
    let elt = document.createElement('div');
    let typeElt = document.createElement('div');
    typeElt.className = 'type';
    typeElt.textContent = pattern.typeStr;
    elt.appendChild(typeElt);
    let infoElt = document.createElement('div');
    infoElt.className = 'info';
    infoElt.textContent = `Min: ${pattern.minStr}\nMax: ${pattern.maxStr}`;
    elt.appendChild(infoElt);
    let checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.addEventListener('change', () => {
        if (checkbox.checked) {
            checkedPatterns.add(pattern);
        } else {
            checkedPatterns.delete(pattern);
        }
    });
    elt.appendChild(checkbox);
    let link = document.createElement('div');
    link.className = 'link';
    link.textContent = 'Copy';
    link.addEventListener('click', async () => {
        await navigator.clipboard.writeText(pattern.rle);
        alert('Copied!');
    });
    elt.appendChild(link);
    if (patternsDiv.children.length === 0) {
        patternsDiv.appendChild(elt);
    } else {
        patternsDiv.insertBefore(elt, patternsDiv.children[0]);
    }
}

if (localStorage.intToolsPatterns) {
    JSON.parse(localStorage.intToolsPatterns).forEach(addPattern);
}

document.getElementById('add').addEventListener('click', () => {
    addPattern(identify(Pattern.fromRLE(rleTextarea.value), 5040));
});

document.getElementById('clear').addEventListener('click', () => {
    localStorage.intToolsPatterns = '[]';
    patterns = [];
    checkedPatterns = new Set();
    while (patternsDiv.lastElementChild) {
        patternsDiv.removeChild(patternsDiv.lastElementChild);
    }
});

let combineOut = document.getElementById('combine-out');

document.getElementById('combine').addEventListener('click', () => {
    let min = new Set();
    let max = new Set(ALL_TRANSITIONS);
    for (let pattern of checkedPatterns) {
        for (let tr of pattern.min) {
            min.add(tr);
        }
        for (let tr of Array.from(max)) {
            if (!pattern.max.includes(tr)) {
                max.delete(tr);
            }
        }
    }
    if (max.size === 0) {
        combineOut.textContent = 'Patterns are incompatible';
    } else {
        combineOut.textContent = `Min: ${transitionsToRule(Array.from(min))}\nMax: ${transitionsToRule(Array.from(max))}`;
    }
});

        </script>
    </body>
</html>