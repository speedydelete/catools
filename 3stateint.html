<!DOCTYPE html>
<html>
    <head>
        <title>3-state INT Ruletable Generator</title>
        <meta charset="utf-8" />
        <!--

            Copyright (c) 2025 speedydelete

            Permission is hereby granted, free of charge, to any person obtaining a copy
            of this software and associated documentation files (the "Software"), to deal
            in the Software without restriction, including without limitation the rights
            to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
            copies of the Software, and to permit persons to whom the Software is
            furnished to do so, subject to the following conditions:

            The above copyright notice and this permission notice shall be included in all
            copies or substantial portions of the Software.

            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
            IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
            FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
            AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
            LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
            OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
            SOFTWARE.

        -->
        <style>

* {
    box-sizing: border-box;
}

html, body {
    position: absolute;
    inset: 0;
    height: 100%;
    width: 100%;
    font-family:'Courier New', Courier, monospace;
}

body {
    margin: 0;
    display: flex;
    flex-direction: row;
    justify-content: center;
}

main {
    padding: 30px;
    padding-bottom: 60px;
    max-width: fit-content;
    display: flex;
    flex-direction: column;
    gap: 2em;
}

h1 {
    width: 100%;
    text-align: center;
    font-size: 2em;
}

#rule {
    width: 60ch;
    height: 10ch;
    max-height: 10ch;
    overflow-y: auto;
    overflow-wrap: anywhere;
    resize: none;
    font-family: inherit;
    font-size: 1em;
}

#buttons {
    width: 100%;
    display: flex;
    flex-direction: row;
    gap: 30px;
}

button {
    padding: 3px 6px;
    font-family: inherit;
    font-size: inherit;
    background-color: inherit;
    color: inherit;
    border: 1px solid black;
}

#out, #help-text {
    flex: 1;
    max-height: calc(100% - 186px - 8em);
    overflow-y: auto;
    overflow-wrap: wrap;
}

#out {
    width: 60ch;
    white-space: pre-wrap;
}

        </style>
    </head>
    <body>
        <main>
            <h1>3-state INT Ruletable Generator</h1>
            <textarea id="rule"></textarea>
            <div id="buttons">
                <button id="generate">Generate</button>
                <button id="download">Download</button>
                <!-- <button id="help">Help</button> -->
            </div>
            <div id="out"></div>
            <!-- <div id="help-text">
                HRT rules are an extension of INT rules that allow for cells beyond the range-1 Moore neighborhood to have an effect on the transitions.<br><br>
                Here is an example: B3/S23/?(3,0)(2,-1)(2,1)=3:S2-i<br><br>
                This is B3/S23 but if the number of alive cells at (3,0), (2,-1), and (2,1) equals 3, S2i is removed.<br><br>
                This is applied for all reflections and rotations, so the rule is isotropic.<br><br>
                You can also chain multiple sections together, like B3/S23/?(3,0)(2,-1)(2,1)=3:S2-i,(4,0)(-4,0)(0,4)(0,-4)=2:B8=3:S8<br><br>
                Ranges can also be used after = and before :, like =2-:B8 (2 to the number of cells), =-2:B8 (0 to 2 cells), or =2-3:B8 (2 or 3 cells).<br><br>
                These rules can be loaded in CAViewer by putting the rule file in the same folder as the CAViewer jar file, and entering the name of the file (including the .rule at the end).<br><br>
            </div> -->
        </main>
        <script>

'use strict';

function error(msg) {
    throw new SyntaxError(msg);
}

const TRANSITIONS = {
    '0c': [0, 0, 0, 0, 0, 0, 0, 0],
    '1c': [1, 0, 0, 0, 0, 0, 0, 0],
    '1e': [0, 1, 0, 0, 0, 0, 0, 0],
    '2a': [1, 1, 0, 0, 0, 0, 0, 0],
    '2c': [1, 0, 1, 0, 0, 0, 0, 0],
    '2e': [0, 1, 0, 0, 1, 0, 0, 0],
    '2i': [0, 1, 0, 0, 0, 0, 1, 0],
    '2k': [0, 1, 0, 0, 0, 0, 0, 1],
    '2n': [1, 0, 0, 0, 0, 0, 0, 1],
    '3a': [1, 1, 0, 0, 1, 0, 0, 0],
    '3c': [1, 0, 1, 0, 0, 0, 0, 1],
    '3e': [0, 1, 0, 1, 1, 0, 0, 0],
    '3i': [1, 0, 0, 1, 0, 1, 0, 0],
    '3j': [0, 0, 1, 0, 1, 0, 1, 0],
    '3k': [0, 1, 0, 1, 0, 0, 0, 1],
    '3n': [1, 0, 1, 1, 0, 0, 0, 0],
    '3q': [1, 0, 0, 1, 0, 0, 0, 1],
    '3r': [0, 1, 1, 0, 0, 0, 1, 0],
    '3y': [1, 0, 1, 0, 0, 0, 1, 0],
    '4a': [1, 0, 0, 1, 0, 1, 1, 0],
    '4c': [1, 0, 1, 0, 0, 1, 0, 1],
    '4e': [0, 1, 0, 1, 1, 0, 1, 0],
    '4i': [1, 0, 1, 1, 1, 0, 0, 0],
    '4j': [0, 0, 1, 1, 1, 0, 1, 0],
    '4k': [0, 1, 1, 1, 0, 0, 0, 1],
    '4n': [1, 0, 0, 1, 0, 1, 0, 1],
    '4q': [1, 1, 0, 1, 0, 0, 0, 1],
    '4r': [0, 1, 1, 0, 1, 0, 1, 0],
    '4t': [1, 1, 1, 0, 0, 0, 1, 0],
    '4w': [1, 0, 0, 1, 0, 0, 1, 1],
    '4y': [1, 0, 1, 0, 0, 1, 1, 0],
    '4z': [1, 1, 0, 0, 0, 0, 1, 1],
};

const VALID_TRANSITIONS = [
    'c',
    'ce',
    'aceikn',
    'aceijknqry',
    'aceijknqrtwyz',
    'aceijknqry',
    'aceikn',
    'ce',
    'c',
];

const LETTERS = 'ABCDEFGHIJKLMNO';

const LETTER_NUMBERS = Array.from(LETTERS);
for (let a of LETTERS.slice(1)) {
    for (let b of LETTERS) {
        LETTER_NUMBERS.push(a + b);
    }
}

for (let key of Object.keys(TRANSITIONS)) {
    if (!key.startsWith('4')) {
        TRANSITIONS[(8 - parseInt(key[0])) + key[1]] = TRANSITIONS[key].map(x => 1 - x);
    }
}

function remapTransition(tr) {
    return [tr[1], tr[2], tr[4], tr[7], tr[6], tr[5], tr[3], tr[0]];
}

function parseTransition(num, tr, isLast, input, output, state) {
    console.log(num, tr, isLast, input, output, state);
    if (tr === '+') {
        if (!isLast) {
            return '';
        }
        let out = '';
        for (let letter of VALID_TRANSITIONS[num]) {
            out += input + ', ' + remapTransition(TRANSITIONS[num + letter].map((x, i) => x === 0 ? 0 : state)).join(', ') + ', ' + output + '\n';
        }
        return out;
    }
    if (tr.startsWith('-')) {
        output = 0;
    }
    tr = tr.slice(1);
    let out = '';
    let letter = '';
    let upper = '';
    for (let char of tr) {
        if (LETTERS.includes(char)) {
            let value;
            if (num < 4) {
                value = LETTER_NUMBERS.indexOf(upper);
            } else {
                upper += char;
                if (upper.length === 2) {
                    value = LETTER_NUMBERS.indexOf(upper);
                } else {
                    continue;
                }
            }
            value = value.toString(2).padStart(num, 0);
            out += input + ', ' + remapTransition(TRANSITIONS[num + letter].map((x, i) => x === 0 ? 0 : (value[i] === '1' ? (state === 1 ? 2 : 1) : state))).join(', ') + ', ' + output + '\n';
            letter = '';
            upper = '';
        } else {
            if (letter) {
                out += input + ', ' + remapTransition(TRANSITIONS[num + letter].map((x, i) => x === 0 ? 0 : state)).join(', ') + ', ' + output + '\n';
            }
            letter = char;
        }
    }
    if (letter) {
        if (!upper) {
            out += input + ', ' + remapTransition(TRANSITIONS[num + letter].map((x, i) => x === 0 ? 0 : state)).join(', ') + ', ' + output + '\n';
        } else {
            let value = null;
            if (num < 4) {
                value = LETTER_NUMBERS.indexOf(upper);
            } else {
                upper += char;
                if (upper.length === 2) {
                    value = LETTER_NUMBERS.indexOf(upper);
                }
            }
            if (value !== null) {
                value = value.toString(2).padStart(num, 0);
                out += input + ', ' + remapTransition(TRANSITIONS[num + letter].map((x, i) => value[i] === '1' ? (state === 1 ? 2 : 1) : state)).join(', ') + ', ' + output + '\n';
            }
        }
    }
    return out;
}

const SECTION_TYPES = [[0, 1, 1], [1, 1, 1], [0, 2, 2], [2, 2, 2], [1, 2, 2], [2, 1, 1]];

function generateTable(rule) {
    let vars = [];
    let sections = rule.split('/');
    if (sections.length < 4 || sections.length > 6) {
        error(`Expected 3 to 5 slashes!`);
    }
    let out = `@RULE Test\n@TABLE\nn_states: 3\nneighborhood: Moore\nsymmetries: rotate4reflect\nvar a1 = {0, 1, 2}\nvar a2 = a1\nvar a3 = a1\nvar a4 = a1\nvar a5 = a1\nvar a6 = a1\nvar a7 = a1\nvar a8 = a1\nvar x = {1, 2}\n`;
    for (let i = 0; i < sections.length; i++) {
        let [input, output, state] = SECTION_TYPES[i];
        let data = sections[i].slice(1);
        let parts = [];
        let current = '';
        for (let char of data) {
            if ('012345678'.includes(char)) {
                if (current !== '') {
                    parts.push(current);
                }
                current = char;
            } else {
                current += char;
            }
        }
        if (current !== '') {
            parts.push(current);
        }
        for (let part of parts) {
            let trs = [];
            let num = parseInt(part[0]);
            let current = '+';
            for (let char of part.slice(1)) {
                if (char === '+' || char === '-') {
                    parts.push(current);
                    current = char;
                } else {
                    current += char;
                }
            }
            trs.push(current);
            trs.reverse();
            for (let i = 0; i < trs.length; i++) {
                out += parseTransition(num, trs[i], i === trs.length - 1, input, output, state);
            }
        }
    }
    out += `x, a1, a2, a3, a4, a5, a6, a7, a8, 0\n@COLORS\n0 0 0 0\n1 255 255 255\n2 91 207 251\n`;
    return out;
}

function generateTableFromInput() {
    let rule = document.getElementById('rule').value;
    let out;
    try {
        out = generateTable(rule);
    } catch (error) {
        if (error instanceof SyntaxError) {
            alert(`Invalid rule! ${error.message}`);
        } else {
            throw error;
        }
    }
    return out;
}

let outElt = document.getElementById('out');
// let helpElt = document.getElementById('help-text');

document.getElementById('generate').addEventListener('click', () => {
    outElt.textContent = generateTableFromInput();
    outElt.style.display = 'block';
    // helpElt.style.display = 'none';
});

document.getElementById('download').addEventListener('click', () => {
    let table = generateTableFromInput();
    let blob = new Blob([table]);
    let url = URL.createObjectURL(blob);
    let link = document.createElement('a');
    link.href = url;
    link.download = document.getElementById('rule').value + '.rule';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
});

// document.getElementById('help').addEventListener('click', () => {
//     outElt.textContent = '';
//     outElt.style.display = 'none';
//     helpElt.style.display = 'block';
// });

        </script>
    </body>
</html>