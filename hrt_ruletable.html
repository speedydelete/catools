<!DOCTYPE html>
<html>
    <head>
        <title>HRT Ruletable Generator</title>
        <meta charset="utf-8" />
        <!--

            Copyright (c) 2025 speedydelete

            Permission is hereby granted, free of charge, to any person obtaining a copy
            of this software and associated documentation files (the "Software"), to deal
            in the Software without restriction, including without limitation the rights
            to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
            copies of the Software, and to permit persons to whom the Software is
            furnished to do so, subject to the following conditions:

            The above copyright notice and this permission notice shall be included in all
            copies or substantial portions of the Software.

            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
            IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
            FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
            AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
            LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
            OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
            SOFTWARE.

        -->
        <style>

* {
    box-sizing: border-box;
}

html, body {
    position: absolute;
    inset: 0;
    height: 100%;
    width: 100%;
    font-family:'Courier New', Courier, monospace;
}

body {
    margin: 0;
    display: flex;
    flex-direction: row;
    justify-content: center;
}

main {
    padding: 30px;
    padding-bottom: 60px;
    max-width: fit-content;
    display: flex;
    flex-direction: column;
    align-items: start;
    gap: 2em;
}

h1 {
    width: 100%;
    text-align: center;
    font-size: 2em;
}

#rule {
    width: 60ch;
    height: 10ch;
    max-width: 60ch;
    max-height: 10ch;
    overflow-y: auto;
    overflow-wrap: wrap;
    resize: none;
    font-family: inherit;
    font-size: 1em;
}

#buttons {
    width: 100%;
    display: flex;
    flex-direction: row;
    justify-content: space-between;
}

button {
    padding: 3px 6px;
    font-family: inherit;
    font-size: inherit;
    background-color: inherit;
    color: inherit;
    border: 1px solid black;
}

#out, #help-text {
    flex: 1;
    max-width: 60ch;
    max-height: calc(100% - 186px - 8em);
    overflow-y: auto;
    overflow-wrap: wrap;
}

#out {
    white-space: pre-wrap;
}

#help-text {
    display: none;
}

        </style>
    </head>
    <body>
        <main>
            <h1>HRT Ruletable Generator</h1>
            <textarea id="rule"></textarea>
            <div id="buttons">
                <button id="generate">Generate</button>
                <button id="download">Download</button>
                <button id="help">Help</button>
            </div>
            <div id="out"></div>
            <div id="help-text">
                HRT rules are an extension of INT rules that allow for cells beyond the range-1 Moore neighborhood to have an effect on the transitions.<br><br>
                Here is an example: B3/S23/?(3,0)(2,-1)(2,1)=3:S2-i<br><br>
                This is B3/S23 but if the number of alive cells at (3,0), (2,-1), and (2,1) equals 3, S2i is removed.<br><br>
                This is applied for all reflections and rotations, so the rule is isotropic.<br><br>
                You can also chain multiple sections together, like B3/S23/?(3,0)(2,-1)(2,1)=3:S2-i,(4,0)(-4,0)(0,4)(0,-4)=2:B8=3:S8<br><br>
                Ranges can also be used after = and before :, like =2-:B8 (2 to the number of cells), =-2:B8 (0 to 2 cells), or =2-3:B8 (2 or 3 cells).<br><br>
                These rules can be loaded in CAViewer by putting the rule file in the same folder as the CAViewer jar file, and entering the name of the file (including the .rule at the end).<br><br>
            </div>
        </main>
        <script>

'use strict';

const TRANSITIONS = {
    '0': {
        'c': [[0, 0, 0, 0, 0, 0, 0, 0]],
    },
    '1': {
        'c': [[0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0]],
        'e': [[0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0]],
    },
    '2': {
        'a': [[0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0]],
        'c': [[0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0]],
        'e': [[0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0]],
        'i': [[0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0]],
        'k': [[0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0]],
        'n': [[1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0]],
    },
    '3': {
        'a': [[0, 0, 0, 0, 1, 0, 1, 1], [0, 0, 0, 1, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0]],
        'c': [[0, 0, 1, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 1, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 1, 0, 0]],
        'e': [[0, 0, 0, 1, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 0, 1, 0], [0, 1, 0, 1, 1, 0, 0, 0]],
        'i': [[0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 1, 0, 1, 0, 0, 1], [1, 0, 0, 1, 0, 1, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0]],
        'j': [[0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 1, 0, 0, 1, 1], [0, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1], [0, 1, 0, 1, 0, 1, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0], [1, 1, 0, 0, 1, 0, 0, 0]],
        'k': [[0, 0, 1, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 1, 0]],
        'n': [[0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 1, 0, 1, 0, 1], [0, 0, 1, 0, 0, 0, 1, 1], [0, 1, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0], [1, 0, 1, 0, 1, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0]],
        'q': [[0, 0, 1, 0, 0, 1, 1, 0], [0, 0, 1, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 1, 0, 0], [0, 1, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 1, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 1]],
        'r': [[0, 0, 0, 1, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1], [0, 1, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 0, 0, 1, 0], [1, 0, 0, 1, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0]],
        'y': [[0, 0, 1, 1, 0, 0, 0, 1], [0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 0, 0, 0, 1, 0]],
    },
    '4': {
        'a': [[0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 1, 0, 1, 1, 1], [0, 0, 1, 0, 1, 0, 1, 1], [0, 1, 1, 0, 1, 0, 0, 1], [1, 0, 0, 1, 0, 1, 1, 0], [1, 1, 0, 1, 0, 1, 0, 0], [1, 1, 1, 0, 1, 0, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0]],
        'c': [[1, 0, 1, 0, 0, 1, 0, 1]],
        'e': [[0, 1, 0, 1, 1, 0, 1, 0]],
        'i': [[0, 0, 0, 1, 1, 1, 0, 1], [0, 1, 1, 0, 0, 0, 1, 1], [1, 0, 1, 1, 1, 0, 0, 0], [1, 1, 0, 1, 0, 1, 1, 0]],
        'j': [[0, 0, 1, 1, 1, 0, 1, 0], [0, 1, 0, 0, 1, 1, 1, 0], [0, 1, 0, 1, 0, 0, 1, 1], [0, 1, 0, 1, 1, 0, 0, 1], [0, 1, 0, 1, 1, 1, 0, 0], [0, 1, 1, 1, 0, 0, 1, 0], [1, 0, 0, 1, 1, 0, 1, 0], [1, 1, 0, 0, 1, 0, 1, 0]],
        'k': [[0, 0, 1, 1, 0, 0, 1, 1], [0, 1, 0, 0, 1, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 1, 1, 0, 0, 0, 1], [1, 0, 0, 0, 1, 1, 1, 0], [1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 1, 0], [1, 1, 0, 0, 1, 1, 0, 0]],
        'n': [[0, 0, 1, 0, 1, 1, 0, 1], [0, 0, 1, 0, 0, 1, 1, 1], [1, 0, 0, 0, 0, 1, 1, 1], [1, 0, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 0, 1], [1, 0, 1, 1, 0, 1, 0, 0], [1, 1, 1, 0, 0, 1, 0, 0], [1, 1, 1, 0, 0, 0, 0, 1]],
        'q': [[0, 0, 1, 1, 0, 1, 1, 0], [0, 1, 1, 0, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0, 1, 1], [1, 1, 0, 1, 0, 0, 0, 1]],
        'r': [[0, 0, 0, 1, 1, 0, 1, 1], [0, 0, 0, 1, 1, 1, 1, 0], [0, 1, 0, 0, 1, 0, 1, 1], [0, 1, 0, 1, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0, 1, 0], [0, 1, 1, 1, 1, 0, 0, 0], [1, 1, 0, 1, 0, 0, 1, 0], [1, 1, 0, 1, 1, 0, 0, 0]],
        't': [[0, 0, 1, 1, 1, 0, 0, 1], [0, 1, 0, 0, 0, 1, 1, 1], [1, 0, 0, 1, 1, 1, 0, 0], [1, 1, 1, 0, 0, 0, 1, 0]],
        'w': [[0, 0, 1, 0, 1, 1, 1, 0], [0, 1, 1, 1, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 1], [1, 1, 0, 0, 1, 0, 0, 1]],
        'y': [[0, 0, 1, 1, 0, 1, 0, 1], [0, 1, 1, 0, 0, 1, 0, 1], [1, 0, 0, 0, 1, 1, 0, 1], [1, 0, 1, 0, 0, 0, 1, 1], [1, 0, 1, 0, 0, 1, 1, 0], [1, 0, 1, 0, 1, 1, 0, 0], [1, 0, 1, 1, 0, 0, 0, 1], [1, 1, 0, 0, 0, 1, 0, 1]],
        'z': [[0, 0, 1, 1, 1, 1, 0, 0], [0, 1, 1, 0, 0, 1, 1, 0], [1, 0, 0, 1, 1, 0, 0, 1], [1, 1, 0, 0, 0, 0, 1, 1]],
    },
    '5': {
        'a': [[0, 0, 1, 0, 1, 1, 1, 1], [1, 0, 0, 1, 0, 1, 1, 1], [1, 1, 1, 0, 1, 0, 0, 1], [1, 1, 1, 1, 0, 1, 0, 0]],
        'c': [[0, 1, 0, 1, 1, 0, 1, 1], [0, 1, 0, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 0, 1, 0], [1, 1, 0, 1, 1, 0, 1, 0]],
        'e': [[1, 0, 1, 0, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 0, 1], [1, 1, 1, 0, 0, 1, 0, 1]],
        'i': [[0, 0, 0, 1, 1, 1, 1, 1], [0, 1, 1, 0, 1, 0, 1, 1], [1, 1, 0, 1, 0, 1, 1, 0], [1, 1, 1, 1, 1, 0, 0, 0]],
        'j': [[0, 0, 1, 1, 0, 1, 1, 1], [0, 1, 1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 1, 1, 1, 1], [1, 0, 1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 0, 1, 0, 1], [1, 1, 1, 0, 1, 1, 0, 0], [1, 1, 1, 1, 0, 0, 0, 1]],
        'k': [[0, 1, 1, 1, 0, 1, 0, 1], [1, 0, 1, 1, 0, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0], [1, 1, 0, 0, 1, 1, 0, 1]],
        'n': [[0, 0, 1, 1, 1, 0, 1, 1], [0, 1, 0, 0, 1, 1, 1, 1], [0, 1, 0, 1, 0, 1, 1, 1], [0, 1, 1, 1, 1, 0, 0, 1], [1, 0, 0, 1, 1, 1, 1, 0], [1, 1, 0, 1, 1, 1, 0, 0], [1, 1, 1, 1, 0, 0, 1, 0], [1, 1, 1, 0, 1, 0, 1, 0]],
        'q': [[0, 0, 1, 1, 1, 1, 1, 0], [0, 1, 1, 0, 1, 1, 1, 0], [0, 1, 1, 1, 0, 1, 1, 0], [0, 1, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 1, 0, 1, 1], [1, 1, 0, 1, 0, 0, 1, 1], [1, 1, 0, 0, 1, 0, 1, 1], [1, 1, 0, 1, 1, 0, 0, 1]],
        'r': [[0, 0, 1, 1, 1, 1, 0, 1], [0, 1, 1, 0, 0, 1, 1, 1], [1, 0, 0, 1, 1, 1, 0, 1], [1, 0, 1, 1, 1, 0, 0, 1], [1, 0, 1, 1, 1, 1, 0, 0], [1, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0], [1, 1, 1, 0, 0, 0, 1, 1]],
        'y': [[0, 1, 0, 1, 1, 1, 0, 1], [0, 1, 1, 1, 0, 0, 1, 1], [1, 0, 1, 1, 1, 0, 1, 0], [1, 1, 0, 0, 1, 1, 1, 0]],
    },
    '6': {
        'a': [[0, 0, 1, 1, 1, 1, 1, 1], [0, 1, 1, 0, 1, 1, 1, 1], [1, 0, 0, 1, 1, 1, 1, 1], [1, 1, 0, 1, 0, 1, 1, 1], [1, 1, 1, 0, 1, 0, 1, 1], [1, 1, 1, 1, 0, 1, 1, 0], [1, 1, 1, 1, 1, 0, 0, 1], [1, 1, 1, 1, 1, 1, 0, 0]],
        'c': [[0, 1, 0, 1, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 0, 1, 1], [1, 1, 1, 1, 1, 0, 1, 0]],
        'e': [[1, 0, 1, 0, 1, 1, 1, 1], [1, 0, 1, 1, 0, 1, 1, 1], [1, 1, 1, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 1, 0, 1]],
        'i': [[1, 0, 1, 1, 1, 1, 0, 1], [1, 1, 1, 0, 0, 1, 1, 1]],
        'k': [[0, 1, 1, 1, 0, 1, 1, 1], [0, 1, 1, 1, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0, 1, 1], [1, 0, 1, 1, 1, 0, 1, 1], [1, 0, 1, 1, 1, 1, 1, 0], [1, 1, 0, 0, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1, 0, 1], [1, 1, 1, 0, 1, 1, 1, 0]],
        'n': [[0, 1, 1, 1, 1, 1, 1, 0], [1, 1, 0, 1, 1, 0, 1, 1]],
    },
    '7': {
        'c': [[0, 1, 1, 1, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 0, 1, 1], [1, 1, 1, 1, 1, 1, 1, 0]],
        'e': [[1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 1]],
    },
    '8': {
        'c': [[1, 1, 1, 1, 1, 1, 1, 1]],
    }
};

const TRANSITIONS2 = Object.fromEntries(Object.entries(TRANSITIONS).flatMap(x => Object.entries(x[1]).map(y => [x[0] + y[0], y[1]])));

function error(msg) {
    throw new SyntaxError(msg);
}

function parseTransition(num, minus, trs) {
    let out = [];
    if (trs.length === 0) {
        for (let char in TRANSITIONS[num]) {
            out.push(num + char);
        }
    } else if (minus) {
        let outTrs = Object.keys(TRANSITIONS[num]).join('');
        for (let char of trs) {
            if (!outTrs.includes(char)) {
                error(`Invalid transition: ${num}${char}!`);
            }
            outTrs = outTrs.replace(char, '');
        }
        for (let char of outTrs) {
            out.push(num + char);
        }
    } else {
        for (let char of trs) {
            if (!(char in TRANSITIONS[num])) {
                error(`Invalid transition: ${num}${char}!`);
            }
            out.push(num + char);
        }
    }
    return out;
}

function _parseTransitions(part, fakeMinus) {
    let out = [];
    let num = parseInt(part[0]);
    let minus = false;
    let trs = '';
    for (let i = 1; i < part.length; i++) {
        let char = part[i];
        if ('012345678'.includes(char)) {
            if (fakeMinus) {
                if (minus) {
                    out.push(...parseTransition(num, false, trs).map(x => [true, x]));
                } else {
                    out.push(...parseTransition(num, false, trs).map(x => [false, x]));
                }
            } else {
                out.push(...parseTransition(num, minus, trs));
            }
            num = parseInt(char);
            minus = fakeMinus ? part[i - 1] === '-' : false;
            trs = '';
        } else if (char === '-') {
            minus = true;
        } else {
            trs += char;
        }
    }
    if (fakeMinus) {
        if (minus) {
            out.push(...parseTransition(num, false, trs).map(x => [true, x]));
        } else {
            out.push(...parseTransition(num, false, trs).map(x => [false, x]));
        }
    } else {
        out.push(...parseTransition(num, minus, trs));
    }
    return out;
}

const ALL_TRANSITIONS = _parseTransitions('012345678');

function parseTransitions(rule, extraNeighbors, fakeMinus) {
    let match = rule.match(/^(B[0-9a-z\-]*)?\/?(S[0-9a-z\-]*)?$/);
    if (!match) {
        error('Invalid rule!');
    }
    let extras = Array.from({length: extraNeighbors}, (_, i) => 'a' + i);
    let birth = [];
    let survive = [];
    for (let i = 1; i < match.length; i++) {
        let group = match[i];
        if (group === undefined) {
            continue;
        }
        let data = _parseTransitions(group.slice(1), fakeMinus);
        if (group[0] === 'B') {
            birth = data.slice();
        } else {
            survive = data.slice();
        }
    }
    if (fakeMinus) {
        return [birth, survive];
    } else {
        let out = [];
        let aUsed = false;
        for (let tr of ALL_TRANSITIONS) {
            let start;
            if (survive.includes(tr)) {
                if (birth.includes(tr)) {
                    aUsed = true;
                    start = 'a';
                } else {
                    start = '1';
                }
            } else if (birth.includes(tr)) {
                start = '0';
            } else {
                continue;
            }
            for (let x of TRANSITIONS2[tr]) {
                out.push([start, ...x, ...extras, '1']);
            }
        }
        return [out, aUsed];
    }
}

function combinations(n, c) {
    if (n === 0) {
        return [[]];
    } else if (c === 0) {
        return [Array.from({length: n}, () => 0)];
    } else if (c === n) {
        return [Array.from({length: n}, () => 1)];
    } else {
        return [
            ...combinations(n - 1, c - 1).map(x => [1, ...x]),
            ...combinations(n - 1, c).map(x => [0, ...x]),
        ];
    }
}

function parseExtra(data) {
    if (data === '') {
        return [[], []];
    }
    if (!data.startsWith('?')) {
        error(`Expected '?' at start of HRT section!`);
    }
    data = data.slice(1);
    let neighbors = [];
    let modifications = [];
    let cns;
    let preSections = data.split(/(,=|,|=)(?=(?:[^()]*\([^()]*\))*[^()]*$)/g);
    let sections = [];
    let prefix = '';
    for (let section of preSections) {
        if (section === '=' || section === ',=') {
            prefix = '=';
            continue;
        } else if (section === ',') {
            continue;
        } else {
            sections.push(prefix + section);
            prefix = '';
        }
    }
    for (let section of sections) {
        if (section.startsWith('(')) {
            let ns = section.slice(1, -1).split(')(').map(x => x.split(/[,.; /]/).map(y => parseInt(y)));
            cns = [];
            for (let n of ns) {
                let index = neighbors.indexOf(x => x[0] === n[0] && x[1] === n[1]);
                if (index === -1) {
                    cns.push(neighbors.length + 9);
                    neighbors.push(n);
                } else {
                    cns.push(index + 9);
                }
            }
        } else if (cns === undefined) {
            error(`Expected left parenthesis`);
        } else if (section.startsWith('=')) {
            let [a, b] = section.split(':');
            if (b === undefined) {
                error(`Expected colon`);
            }
            let num = a.slice(1);
            let nums = [];
            if (num.includes('-') || num.includes('+')) {
                let [start, end] = num.split(/[-+]/);
                start = start === '' ? 0 : parseInt(start);
                end = end === '' ? cns.length : parseInt(end);
                for (let i = start; i <= end; i++) {
                    nums.push(i);
                }
            } else {
                nums.push(parseInt(num));
            }
            modifications.push([cns.slice(), nums, b]);
        } else {
            error(`Expected equals sign or left parenthesis`);
        }
    }
    let out = [];
    let extras = Array.from({length: neighbors.length}, (_, i) => 'a' + i);
    for (let [ns, nums, rule] of modifications) {
        let [birth, survive] = parseTransitions(rule, 0, true);
        let trs = [];
        for (let [minus, tr] of birth) {
            for (let x of TRANSITIONS2[tr]) {
                let data = Array.from({length});
                trs.push(['0', ...x, ...extras, minus ? '0' : '1']);
            }
        }
        for (let [minus, tr] of survive) {
            for (let x of TRANSITIONS2[tr]) {
                trs.push(['1', ...x, ...extras, minus ? '0' : '1']);
            }
        }
        for (let num of nums) {
            for (let str of combinations(ns.length, num)) {
                for (let tr of trs) {
                    tr = tr.slice();
                    for (let i = 0; i < ns.length; i++) {
                        tr[ns[i]] = str[i];
                    }
                    out.push(tr);
                }
            }
        }
    }
    return [out, neighbors.map(x => `(${x[0]}, ${x[1]})`)];
}

function generateTable(rule) {
    let vars = [];
    let sections = rule.split('/');
    if (sections.length < 2) {
        error(`Expected at least 1 slash!`);
    }
    let [trs, neighbors] = parseExtra(sections.slice(2).join('/'));
    let [trs2, aUsed] = parseTransitions(sections[0] + '/' + sections[1], neighbors.length);
    trs.push(...trs2);
    let neighborhood = ['(-1, -1)', '(0, -1)', '(1, -1)', '(-1, 0)', '(1, 0)', '(-1, 1)', '(0, 1)', '(1, 1)', ...neighbors];
    trs.push(['1', ...Array.from({length: neighborhood.length}, (_, i) => 'a' + i), 0]);
    let out = `@RULE ${rule}\n@TABLE\nn_states:2\nneighborhood:[${neighborhood.join(', ')}]\nsymmetries:rotate4reflect\n`;
    if (aUsed) {
        out += 'var a = {0,1}\n';
    }
    out += Array.from({length: neighborhood.length}, (_, i) => `var a${i} = {0,1}`).join('\n') + '\n';
    out += trs.map(x => x.join(', ')).join('\n');
    return out;
}

function generateTableFromInput() {
    let rule = document.getElementById('rule').value;
    let out;
    try {
        out = generateTable(rule);
    } catch (error) {
        if (error instanceof SyntaxError) {
            alert(`Invalid rule! ${error.message}`);
        } else {
            throw error;
        }
    }
    return out;
}

let outElt = document.getElementById('out');
let helpElt = document.getElementById('help-text');

document.getElementById('generate').addEventListener('click', () => {
    outElt.textContent = generateTableFromInput();
    outElt.style.display = 'block';
    helpElt.style.display = 'none';
});

document.getElementById('download').addEventListener('click', () => {
    let table = generateTableFromInput();
    let blob = new Blob([table]);
    let url = URL.createObjectURL(blob);
    let link = document.createElement('a');
    link.href = url;
    link.download = document.getElementById('rule').value + '.rule';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
});

document.getElementById('help').addEventListener('click', () => {
    outElt.textContent = '';
    outElt.style.display = 'none';
    helpElt.style.display = 'block';
});

        </script>
    </body>
</html>